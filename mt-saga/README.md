# 简介
## 基于Saga与事件驱动的分布式事务管理中心
# 关键词
- 本地事务：单独服务可以完成的逻辑单元
- 分布式事务：需要由多个服务共同参与完成的一个完整逻辑单元，由多个本地事物组成
- 正向分布式事务：正向逻辑，例如下订单
- 逆向分布式事务：逆向逻辑，例如（取消）下订单
- Saga：通过正向分布式事务与逆向分布式事务来达到最终一致性的分布式事务解决方案
- 空写入：系统单纯记录此次变化，但并不会有任何其余的改动
- 幂等：一次或多次相同操作对系统的影响是等价的
- 正向事件：正向分布式事务的一个执行单元，对应一个本地事务
- 逆向事件：逆向分布式事务的一个执行单元，对应一个本地事务
- 悬挂事件：当逆向事件先于正向事件被处理，则正向事件此时同时为悬挂事件
- 事件：系统在某个时刻发生事情的记录
# 基本组件
- 状态机：根据不同的事件来决定创建什么分布式事务
- 各种分布式事务对象
- MQ中间件：负责事件的投递与接收
- 分布式锁：确保同一时间只能有一个线程获得锁
- 事件发布器：扫描记录的事件并投递到MQ中间件的定时任务
# 基本要求
- 参与服务幂等
- 参与服务支持事件
- 参与服务支持正向事件与逆向事件：例如增加库存与（取消）增加库存
- 参与服务成功处理事件则生成回复事件，否则不做任何回复
- 参与服务同一时间只能有一个正向事件或者逆向事件被执行
- 参与服务支持空写入，即：如果执行正向事件时逆向事件已存在则空写入，执行逆向事件时如果正向事件不存在则空写入
- 事件可以重试
- 正向分布式事务只对应一个逆向分布式事务
- 参与对象（例如订单）在同一时间内只能有一个分布式事务，否则增加事务冲突
- 本地事务失败是发布回滚事件，此事件会自动创建回滚分布式事务，并不受上述条件限制
# 示例（正向事件：创建订单）
- 假定一个创建订单需要涉及的本地事务有：生成支付链接，保存订单信息，扣减订单库存，清空购物车，其中保存订单信息需要等待支付链接生成
## 步骤1
- Saga收到**创建订单事件**
- 尝试获得分布式锁（key为提前生成的订单号）(可选)
- 创建状态机，验证事件之后再依据订单当前状态与事件生成对应的事件，这里为：**创建**创建订单分布式事务事件（注意此时并没有创建分布式事务）并写入数据库
- 事件发布器扫描并投递新事件到MQ
## 步骤2
- Saga收到**创建**创建订单分布式事务事件
- 查找锁（key为订单号）来保证系统在同一时间只有一个订单事务，以此来解决数据中间态的问题
- （锁已存在）忽略该事件
- （锁不存在）生成创建订单分布式事务与其正向事件，这里为：生成支付链接事件，扣减订单库存事件，清空购物车事件，分布式事务标记为已开始并写入数据库
- 事件发布器扫描并投递新事件到MQ
## 步骤3（生成支付链接成功）
- Saga收到**生成支付链接成功回复事件**
- 尝试获得分布式锁（key为分布式事务ID）
- 更新对应分布式事务的本地事件状态为成功，创建：保存订单信息事件并写入数据库
- 事件发布器扫描并投递新事件到MQ
## 步骤3（保存订单信息成功）
- Saga收到**保存订单信息成功回复事件**
- 尝试获得分布式锁（key为分布式事务ID）
- 更新对应分布式事务的本地事件状态为成功，如果本地事物全部成功则分布式事务成功并创建**创建订单分布式事务成功事件**，删除锁，写入数据库
- 事件发布器扫描并投递新事件到MQ
# 示例（逆向事件：创建订单）
## 步骤3（清空购物车失败）
- Saga收到**清空购物车失败事件**（注意这个事件并不是回复事件）
- Saga生成**创建**取消创建订单分布式事务事件并写入数据库
- 事件发布器扫描并投递新事件到MQ
## 步骤4
- Saga收到**创建**取消创建订单分布式事务事件
- 生成（取消）创建订单分布式事务与其逆向事件，这里为：（取消）生成支付链接事件，（取消）扣减订单库存事件，（取消）清空购物车事件，（取消）保存订单信息事件，分布式事务标记为已开始并写入数据库
- 事件发布器扫描并投递新事件到MQ
## 步骤5（取消保存订单信息成功）
- Saga收到**取消保存订单信息成功回复事件**
- 尝试获得分布式锁（key为分布式事务ID）
- 更新对应分布式事务的本地事件状态为成功，如果本地事物全部成功则分布式事务成功并创建**取消创建订单分布式事务成功事件**，写入数据库
- 事件发布器扫描并投递新事件到MQ
## 步骤6（取消创建订单分布式事务成功）
- Saga收到**取消创建订单分布式事务成功**
- 将已开始的正向事务重新投递到MQ
## 步骤7（创建订单分布式事务或取消创建订单分布式事务成功）
- Saga收到**创建订单分布式事务成功事件**或**取消创建订单分布式事务成功事件**
- 如果对应的两个事务都为成功则校验：如果正向事件为空操作则逆向事件必须也是空操作，反之亦然